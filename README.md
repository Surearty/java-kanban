<h1 align="center"> java-kanban yandex practicum </h1>
<h2 align="center">Учебный проект Таск-менеджер на курсе <a href="https://practicum.yandex.ru/java-developer/" target="_blank">java разработчик</a></h2>

<h2 align="center"> Планировщик задач </h2>
<p>Задача проекта:</p>  
<p>написать бэкенд трекера задач. В итоге должна получиться программа, отвечающая за формирование модели данных для этой страницы:</p>
<img src="https://github.com/Surearty/java-kanban/raw/main/images/Image.png" alt="My Image">

<h2 align="center"> Логика работы и функционал</h2>

__У нас есть три вида задач: Задача, Эпик, Подзадача.__  
__Задача:__
 * Название, кратко описывающее суть задачи (например, «Переезд»).
 * Описание, в котором раскрываются детали.
 * Уникальный идентификационный номер задачи, по которому её можно будет найти.
 * Статус, отображающий её прогресс. Мы будем выделять следующие этапы жизни задачи:
   * a. NEW — задача только создана, но к её выполнению ещё не приступили.
   * b. IN_PROGRESS — над задачей ведётся работа.
   * c. DONE — задача выполнена.  

__Эпик - это большая задача, разбитая на подзадачи. Главные выводы из этого:__  
__Эпик:__
  * Для каждой подзадачи известно, в рамках какого эпика она выполняется.
  * Каждый эпик знает, какие подзадачи в него входят.
  * Завершение всех подзадач эпика считается завершением эпика.
<img src="https://github.com/Surearty/java-kanban/raw/main/images/задача.png" alt="tasks">
<h3 align = "center">интерфейс TaskManager</h3>  

__Интерфейс в Java__ — это специальный тип, который используется для описания возможностей, которыми должны обладать классы, реализующие этот интерфейс. Другими словами, интерфейс говорит классам, что делать, но не как это делать.  
__Основные моменты про интерфейсы:__  
  * __Определение поведения:__ Интерфейс определяет, какие методы должен реализовать класс, но не содержит их реализацию.
  * __Реализация множественного наследования:__ В Java не поддерживается множественное наследование классов, но класс может реализовывать множество интерфейсов, обеспечивая способ обойти это ограничение.
  * __Отделение контракта от реализации:__ Интерфейсы позволяют разработчику отделить определение "что должен делать класс" от "как он это делает".
  * __Повышение модульности:__ Интерфейсы способствуют написанию модульного кода, так как классы могут менять реализуемые интерфейсы без изменения определения интерфейса.
  * __Поддержка полиморфизма:__ Интерфейсы позволяют использовать полиморфизм, где объекты разных классов, реализующих один интерфейс, могут использоваться взаимозаменяемо.

__Для начала создадим интерфейс TaskManager, в нем мы соберем список методов которые будут у всех объектов менеджеров:__
```java
public interface TaskManager {

    ArrayList<Task> getAllTasks(TaskType type);

    void removeTasks();  //Удалить Все задачи

    void removeEpics();  //Удалить Все эпики

    void removeSubtasks();  //Удалить Все подзадачи

    Task getTask(int taskId);  //Получить задачу по id

    void createTask(Task task);  //Создать задачу

    Task removeById(int id);  //Удалить по ID

    void updateTask(Task task);  //Обновить задачу

    ArrayList<SubTask> getEpicSubTask(Epic epic);  //Получить список подзадач конкретного эпика

    List<Task> getHistory();  //Получить историю просмотра задач
}
```
<h3 align = "center">класс InMemoryTaskManager</h3>

__Теперь, когда есть интерфейс нашего менеджера задач, мы создадим класс InMemoryTaskManager - это первый менеджер задач в проекте,
он хранит всю информацию в оперативной памяти (т.е. пока работает наша программа). Кроме реализации методов интерфейса TaskManager,
класс InMemoryTaskManager хранит все Задачи, Эпики, Подзадачи в HashMap - где ключем будет id, а значением задача.__  
```java
    private int taskId;  //при создании любой новой задачи/подзадачи/эпика увеличивается на +1
    private final HashMap<Integer, Task> tasks;  //Задачи
    private final HashMap<Integer, Epic> epics;  //Эпики
    private final HashMap<Integer, SubTask> subTasks;  //Подзадачи
```
<h3 align = "center">интерфейс HistoryManager</h3>

__HistoryManager__ - отдельный интерфейс для управления историей просмотров.  
У него будет два метода:  
```java
public interface HistoryManager {
    void add(Task task);  //должен помечать задачи как просмотренные
    List<Task> getHistory();  //возвращает список просмотренных задач
}
```
<h3 align = "center">класс InMemoryHistoryManager (история просмотров)</h3>

Данный класс предназначен для хранения списка просмотренных задач

<h3 align = "center">Утилитарный класс Managers</h3>

__Утилитарный класс в Java__ – это класс, который предназначен исключительно для предоставления статических методов и обычно не предполагает создания экземпляров самого класса.  
_Проще говоря, тот случай, когда нам нужнет какой то метод, а сам объект класса, который реализует этот метод нам не нужен, Используем Утилитарный класс._  
__Особенности утилитарного класса:__  
  * __Имеет только статические методы и статические поля.__ Статические методы и поля принадлежат классу, а не объекту класса. Это означает, что они могут быть вызваны напрямую из класса, без необходимости создания экземпляра класса.
  * __Не предназначен для создания объектов.__ Поскольку утилитарный класс предназначен только для методов, обычно нет смысла создавать объект этого класса. Для предотвращения создания экземпляра класса конструктор утилитарного класса делается приватным.
  * __Часто объявляется как final.__ Класс объявляется как final, чтобы предотвратить его наследование.
  * __Примерами утилитарных классов в Java Standard Library являются Math, Arrays, Collections и другие.__

__Наш класс Managers:__
```java
public final class Managers {
    public static TaskManager getInMemoryTaskManager() {
        return new InMemoryTaskManager();  // Хранит списки всех задач
    }

    public static HistoryManager getDefaultHistory() {
        return new InMemoryHistoryManager();  // Хранит историю просмотров задач
    }
}
```
